Summoner’s Ledger — Game Vision (clean write-up) High concept A Pokémon × D&D hybrid roguelike. You roam forward through an overworld, trigger encounters, and fight turn-based battles that use D&D-style rolls (attack rolls, crits, damage dice). Instead of Pokémon you collect Vessels (embodiments of D&D classes). Instead of Pokéballs you use spells from your Ledger to bind/capture Vessels. Human opponents are Summoners. Lexicon (terminology map) Vessels = collectible creatures themed on D&D classes (Fighter, Rogue, Wizard, etc.). Ledger = your spellbook; houses capture spells and utility effects. Spells (Ledger) = functionally like Pokéballs (capture attempts), plus buffs/debuffs. Summoners = trainer-style human opponents who command Vessels. Vesseldex = compendium of every Vessel species you’ve encountered/captured. Core loop Overworld travel — Auto/forward walk. Random encounters occur at intervals. Encounter — A Vessel (or Summoner) appears. A popup frames the battle start. Turn-based combat — Choose actions; D&D rolls resolve outcomes. Outcome — KO the enemy (XP/loot) or capture it (adds to party). Return to overworld — Distance and encounter counters progress; special events trigger (shops, bosses, map swaps). Roguelike flow — A run ends on party wipe; scoreboard records stats; start a fresh run. Encounters & generation On encounter, the enemy Vessel’s stat block is rolled: Abilities (STR/DEX/CON/INT/WIS/CHA): 4d6 drop lowest (per ability). Level: starts at 1 (scales with distance/encounter count later). HP: d8 per level + CON mod per level (min 1). AC: 10 + DEX mod (base). Attacks: class-flavored (e.g., Shadow Claw, Fire Bolt, Shortsword), each with a to-hit = proficiency + relevant ability mod, and damage as dice + mod (e.g., 1d6+DEX). Summoner encounters: Summoners own 1–3 random Vessels (rolled when the fight begins) with the same stat system. Turn-based combat (D&D flavored) Initiative: simple alternating turns at first; later you can add initiative rolls (d20+DEX). On your turn choose one: Attack (weapon or class move) Cast (class spell or Ledger spell) Capture attempt (see below) Item/Defend/Swap (future) Attack roll: d20 + attack bonus vs AC. Nat 20 = crit (double dice by default). Nat 1 = automatic miss. Damage: roll weapon/spell dice + relevant ability mod (and apply resist/weakness later). Status (later): conditions like Shaken (disadvantage), Enflamed (DoT), Guarded (AC buff). Capturing (Ledger spell) Action: “Cast Binding” (your Ledger capture spell). Check: opposed capture DC that improves when the target is weakened. Base DC rises with Vessel rarity/level. Modifiers: + if target is low HP, debuffed, or outnumbered; − if enraged/buffed. Resolve as spell attack (d20 + spell mod) vs DC, or as a save the target must make (target rolls d20 + WIS/CHA save vs your spell DC). Pick one model and stick to it. On success: Vessel is captured → added to first free party slot; Vesseldex updated. On fail: small backlash (chip damage or momentum loss). Progression XP & Leveling: Defeating/capturing grants XP to the active Vessel (and a smaller amount to benched allies); level increases max HP, to-hit, damage, and sometimes unlocks a move. Encounter counter: Global encounter_count increments every fight. Use it to: Gate biomes/maps (e.g., lava map at 100 encounters). Escalate enemy levels/rarity. Trigger boss Summoners at milestones (e.g., 20/50/100). Scoreboard (per run): Total encounters Bosses defeated Distance traveled Rares captured Final party and highest levels Vesseldex: Entries for seen vs captured Shows species art, class, typical moves, and best roll seen. Completion % becomes a meta goal. Boss Summoners Appear at fixed milestones (e.g., after 20 encounters, then every 30). Team of 2–3 tuned Vessels (slightly above curve). On defeat: guaranteed loot (rare spell, permanent buff, or map transition). Maps/biomes Start in Forest/Road. At 100 encounters → switch to Lava map (harder baseline). Future: Swamp, Ruins, Snowfield, Astral. Biomes can bias class/element spawns and add hazards. Shops & events (future) Shops: between encounters; spend currency to learn Ledger spells, buy items, heal. Random events: altars, trainers, riddles—small choices with persistent buffs/debuffs (roguelike spice). Systems checklist (MVP → Stretch) MVP Overworld walk + encounter trigger Vessel stat generation on encounter Turn-based combat with: Attack roll (d20), nat 20 crits, damage dice Simple AI (attack or capture-resist buff) Capture spell with HP-based modifier Party of up to 6 + HUD tokens Save/continue (party, position, counters) Vesseldex (seen/captured) Encounter counter + scoreboard Boss Summoner at least one milestone Map swap at 100 encounters Stretch Advantage/disadvantage conditions Status effects & conditions Multiple capture spell variants (Quick Bind, Heavy Seal) Shops & currency More biomes and hazard rules Rarity tiers & shiny variants Meta progression (unlock starting Ledger spells, cosmetics) Balancing notes (starting points) Player hit chance target ~65% vs equal-level foes (tune AC/proficiency). Capture chances: Full HP common: ~20–25% <35% HP common: ~55–65% Rare baseline −15–20% from common Crits: d20 natural 20 → double dice only (not flat bonuses) to keep spikes exciting but sane. Data you’ll want to track (per run) encounter_count, distance_travelled, biome party_slots (surfaces) + party_slots_names (filenames) For each Vessel: class, level, abilities, mods, HP/AC, moves, XP vesseldex_seen, vesseldex_caught sets scoreboard snapshot on death or boss victory My exact thought= Pokemon and DND hybrid as a roguelike. Pokemon style fighting, capturing and storing Pokemons = Vessels (DND classes) Pokeballs = Spells from you ledger Trainers = Summoners Fighting will work turn based like pokemon, but with DND dmg effects. So fx Nat 20 = crit and you roll dmg, if youre a fighter you attack with sword If youre a mage you use fireball etc Gameplay loop will be - Walk ahead in overworld, encounter Vessels, kill them or catch them - Get xp - back to overworld, maybe encounter summoner and trainerbattle At certain points Boss summoners will appear Whenever you encounter a vessel stats will be rolled and that will indicate the HP, AC stat, and main stat if Rogue = Dexterity, 10+0 8-1 12+1 (DND rules) Summoners will have random vessels with random stats Shops will come in the future, and maybe even random events where you can get buffs since its a roguelike I want encounter counter, scoreboard, Vesseldex (Pokedex), more maps fx after 100 encounters you go to lava map


Import patterns (what you’re using now)
In main.py:

python
Kopier kode
from world import assets, actors, world, procgen
from systems import save_system as saves, theme, ui, audio, party_ui
from screens import (
    menu_screen, char_select, name_entry,
    black_screen, intro_video, settings_screen, pause_screen
)
Inside screens/ modules:

python
Kopier kode
from systems import ui
from systems import audio as audio_sys
from systems import party_ui
from systems import save_system as saves
from systems import theme
Inside world/ modules (use relative imports between world files):

python
Kopier kode
from .vessel_gen import generate_vessel_stats
from .roller import Roller
Notes to avoid routing/import pain
Always run the game from the project root:

bash
Kopier kode
cd SummonersLedger
python main.py
Keep __init__.py in screens/, systems/, and world/ (can be empty).

You are working on Summoner’s Ledger. Follow these immutable audio rules:

1) SFX master volume
- Treat systems/audio.py as the single source of truth for SFX volume.
- Always use audio_sys.get_sfx_volume() to read the master and audio_sys.set_sfx_volume(v, bank) to change it.
- Never hard-set per-sound volumes to constants like 1.0. Let the master control loudness.

2) One way to play sounds
- Do NOT call pygame.Sound.play() directly.
- ALWAYS play SFX through audio_sys.play_sound(snd, vol_scale=1.0, fade_ms=0) so the master volume is honored.
- For UI clicks, call audio_sys.play_click(bank, vol_scale=1.0) (this auto-falls back to a generated beep).
- For looping SFX, use audio_sys.play_looping_sfx(bank, key) and audio_sys.stop_looping_sfx(bank, key).

3) Loading sounds
- Prefer loading via the global AudioBank returned by audio_sys.get_global_bank() / audio_sys.load_all().
- If you must create a pygame.Sound directly (e.g., ad-hoc file), do not set its volume; let audio_sys.play_sound() scale it.
- For any new SFX assets, put them under one of the SFX dirs so load_all() picks them up; keys are basename (lowercased, no extension).

4) Music
- Only use audio_sys.play_music(bank, key, loop=True, fade_ms=800) and audio_sys.stop_music(fade_ms=600).
- Never mix music and SFX channels manually.

5) Settings screen integration
- The SFX slider must call audio_sys.set_sfx_volume(val, audio_bank) and never iterate sounds to set_volume.
- The SFX slider’s displayed value must be audio_sys.get_sfx_volume().
- The music slider uses pygame.mixer.music.get/set_volume as usual.

6) Mixer init and channels
- Initialize audio ONLY via audio_sys.init_audio(); do not pre_init/init the mixer elsewhere.
- Do not change mixer channel counts or formats outside systems/audio.py.

7) Fades, ducking, and feedback
- If you need a fade for SFX, pass fade_ms through audio_sys.play_sound().
- For quick UI feedback after changing SFX volume, optionally audio_sys.play_click(audio_bank).

8) Error handling & fallbacks
- If a sound key/path isn’t found, log a single concise warning and continue without crashing.
- Never block the game loop waiting on audio.

9) Paths & naming
- Use relative asset paths; keys are normalized via filename (lowercase, no extension).
- Prefer descriptive names: e.g., “ui_click”, “book_open”, “boh”, “caught_sfx”, or move label slugs.

10) When reviewing or modifying old code
- Replace any direct snd.play(), ch.play(), or snd.set_volume(…) calls with audio_sys.play_sound(…).
- Remove ad-hoc 1.0 volume lines; rely on the SFX master.

Examples:
# BAD
snd = pygame.mixer.Sound("Assets/Music/Sounds/BookOpen.mp3")
snd.set_volume(1.0)
snd.play()

# GOOD
snd = pygame.mixer.Sound("Assets/Music/Sounds/BookOpen.mp3")
audio_sys.play_sound(snd)  # respects SFX master

Turn-based loop: the shape
PLAYER_TURN ──► RESOLVING ──► ENEMY_TURN ──┐
    ▲                                      │
    └──────────────────────────────────────┘

Core modules (who does what)

combat/wild_vessel.py — the scene controller

Owns turn phases, delays, fade/VFX, result cards, input routing.

Hands off to AI and back to player.

combat/moves.py — the combat executor

Move registry, PP store/spend, to-hit/damage, enemy HP/ally HP updates.

Busy flag (is_resolving) to debounce scene transitions.

combat/enemy_ai.py — the brain

Chooses an enemy move and calls moves.queue_enemy(...).

combat/btn/*_action.py — UI popups

Battle/Bag/Party/Run open/close and set gs._turn_ready = False when an action consumes the turn.

rolling/ui.py — Dice popup (modal; consumes input while up).

systems/audio.py — centralized SFX/music so every sound respects master volume.

State you care about
Phase & timing (in wild_vessel.py)

PHASE_PLAYER, PHASE_RESOLVE, PHASE_ENEMY

st["phase"] — current phase

Enemy think buffer:
st["enemy_think_until"] = pygame.time.get_ticks() + 2000
(set inside _begin_enemy_phase()) → change 2000 to your ms.

st["ai_started"] — ensures AI fires once per enemy phase.

“Scene is busy?” gates

We only phase-switch when nothing else is happening:

Moves running: moves.is_resolving()

Cinematics/overlays:

st["result"] (result card live)

st["cap_vfx_playing"] (capture swirl)

st["enemy_fade_active"] (enemy KO fade)

st["swap_playing"] (ally swap swirl)

roll_ui.is_active() (dice popup)

All of those feed a scene_busy boolean before transitions.

Player turn completion

When the player commits to something (e.g., uses a scroll, chooses a move), set:

gs._turn_ready = False (bag / move handlers do this)

The scene sees that and moves PLAYER_TURN → RESOLVING.

The phase handlers (minimal logic)
Player → Resolving
if st["phase"] == PHASE_PLAYER:
    if gs._turn_ready is False or moves.is_resolving():
        _begin_resolving_phase(st)  # closes popups, sets phase

Resolving → Enemy
scene_busy = (st["result"] or st["cap_vfx_playing"] or
              st["enemy_fade_active"] or st["swap_playing"] or
              roll_ui.is_active())

if st["phase"] == PHASE_RESOLVE and not moves.is_resolving() and not scene_busy:
    turn_order.next_turn(gs)
    _begin_enemy_phase(st)   # sets enemy_think_until = now + buffer

Enemy → (wait buffer) → AI acts → Player
if st["phase"] == PHASE_ENEMY:
    now = pygame.time.get_ticks()
    if (not st["ai_started"]
        and now >= st["enemy_think_until"]
        and not moves.is_resolving()
        and not scene_busy):
        enemy_ai.take_turn(gs)       # queues enemy move, plays sfx
        st["ai_started"] = True

    # after AI finishes and scene is quiet, give turn back
    if st["ai_started"] and not moves.is_resolving() and not scene_busy:
        if turn_order.current_actor(gs) != "player":
            turn_order.next_turn(gs)
        gs._turn_ready = True
        _begin_player_phase(st)

How a move executes (ally & enemy)
Ally path (player-initiated)

UI picks a move (Battle popup) → calls moves.queue(gs, move_id).

moves.queue(...):

checks/ spends PP

sets busy flag during resolution

runs _perform_basic_attack(...)

computes hit/crit & damage, updates encounter_stats["current_hp"]

emits a result card into gs._wild["result"] or KO flow

plays per-move SFX via systems.audio

Enemy path (AI-initiated)

enemy_ai.take_turn(gs) picks a move id, calls moves.queue_enemy(gs, move_id).

Internally mirrors ally math; writes damage to ally stats:

party_vessel_stats[idx]["current_hp"]

Emits info result card like “Enemy used X – Hit for N”.

Busy flag:
moves._set_resolving(True/False) brackets the whole attack so the scene knows when animations/rolls are “in flight.”

The quick knobs (common tweaks)

Enemy wait before acting (ms):
wild_vessel._begin_enemy_phase() → + 2000 (e.g., + 500 for 0.5s)

KO fade duration (s):
ENEMY_FADE_SEC

Result card fade (ms):
RESULT_FADE_MS

Summon slide time (s):
SUMMON_TIME

Capture swirl duration (s):
SWIRL_DURATION

Defeat debounce (ms):
st["defeat_debounce_ms"] (init’d to 300)

Move PP cap per move:
moves.Move.max_pp (default 20) or per-entry in _MOVE_REGISTRY

SFX

UI clicks / open-close: via systems.audio helpers

Per-move SFX files: Assets/Music/Moves/<slug>.mp3
(slug from label, e.g., "Thorn Whip" → "thorn_whip.mp3")

Minimal pseudo-flow (copy-ready)
def handle(events, gs):
    st = gs._wild

    # 1) Always give dice UI first crack
    if roll_ui.is_active():
        for e in events: roll_ui.handle_event(e)
        if not roll_ui.is_active():
            # resolve post-roll effects here
        return

    # 2) Player input only when not enemy-phase-locked
    if st["phase"] != PHASE_ENEMY:
        route_buttons_and_popups(events, gs)

    # 3) Phase transitions
    resolving = moves.is_resolving()
    scene_busy = any([st["result"], st["cap_vfx_playing"], st["enemy_fade_active"],
                      st["swap_playing"], roll_ui.is_active()])

    if st["phase"] == PHASE_PLAYER:
        if gs._turn_ready is False or resolving:
            _begin_resolving_phase(st)

    if st["phase"] == PHASE_RESOLVE and not resolving and not scene_busy:
        turn_order.next_turn(gs)
        _begin_enemy_phase(st)   # sets enemy_think_until = now + BUFFER_MS

    if st["phase"] == PHASE_ENEMY:
        if time_now() >= st["enemy_think_until"] and not resolving and not scene_busy and not st["ai_started"]:
            enemy_ai.take_turn(gs)
            st["ai_started"] = True

        if st["ai_started"] and not resolving and not scene_busy:
            turn_order.next_turn(gs)
            gs._turn_ready = True
            _begin_player_phase(st)


XP system — quick reference
⚔️ XP System (Summary)

Files:

systems/xp.py → handles rewards, level-ups

combat/wild_vessel.py → queues + shows XP cards

screens/ledger.py → displays bar + numbers

Data per slot:
level, xp_current, xp_needed, xp_total, hp/current_hp, class_name, abilities

Reward formula:
reward = max(1, round(1 * enemy_lvl**0.75 * rarity_mult * diff_mult))

rarity: common 1.0 / uncommon 1.3 / rare 1.7 / boss 2.2

diff_mult = 0.6–1.6 × (level difference)

Distribution:

Active: 100%

Living bench: 30% each

0 XP if fainted or missing class_name

Level-up:
When xp_current ≥ xp_needed(level) → rebuild stats via combat.stats.build_stats, keep abilities + HP ratio.

Ledger:
Reads xp_current / xp_needed → shows bar + XP: X / Y.

Flow:
Defeat or capture → queue XP → show “Experience Gained” card (click to dismiss) → apply XP → return to overworld.

How HP works in Summoner’s Ledger

Single source of truth (state):

Allies: gs.party_vessel_stats[i] (dict per slot)

hp = max HP, current_hp = current HP

Enemy: gs.encounter_stats (dict) with the same fields.

Defaults: If current_hp is missing, treat it as full (current_hp = hp).

Who updates HP: combat/moves.py (damage/heal during resolution). Level-ups in systems/xp.py rebuild stats and preserve HP ratio when max HP changes.

Who reads HP: UI/flows like wild_vessel.py, summoner_battle.py, battle.py, party_action.py, party_ui.py, screens/ledger.py—they compute bars/KO/greys purely from the stored values.

KO & forced switch: If an ally’s current_hp <= 0, battle flow triggers a forced party switch (unless no living allies → defeat). Enemy at 0 → defeat/capture path, XP award, exit as designed.

TL;DR: HP is not duplicated; it lives in the state dicts above. All modules just read or mutate current_hp (and keep hp as the cap).